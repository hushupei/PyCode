Python 2.7.5 (default, May 15 2013, 22:43:36) [MSC v.1500 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> f=file('hello.txt')
>>> lines=f.readlines()
>>> for line in lines:
... 	print (line,)
... 
('hello world\n',)
('hello china\n',)
('hello hushupei',)
>>> f.close()
>>> rf=open('hello.txt')
>>> content=rf.read()
>>> print(content)
hello world
hello china
hello hushupei
>>> rf.close()
>>> f=file('hello.txt','w+')
>>> li=['hello NGI','hello SDN']
>>> f.writelines(li)
>>> f.close()
>>> f=file('hello.txt','a+')
>>> new_line='\nhello world\nhello china\nhello hushupei'
>>> f.write(new_line)
>>> f.close()
>>> import os
>>> rename('./hello.txt','helloworld.txt')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'rename' is not defined
>>> print stat('./hello.txt')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'stat' is not defined
>>> print os.stat('./hello.txt')
nt.stat_result(st_mode=33206, st_ino=0L, st_dev=0, st_nlink=0, st_uid=0, st_gid=0, st_size=60L, st_atime=1468591074L, st_mtime=1468591989L, st_ctime=1468591074L)
>>> os.rename('./hello.txt','helloworld.txt')
>>> os.remove('./haha.txt')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
WindowsError: [Error 2] : './haha.txt'
>>> f=file('haha.txt','w+')
>>> f.close()
>>> os.remove('./haha.txt')
>>> os.abspath('./')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute 'abspath'
>>> os.abspath('.')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute 'abspath'
>>> import os.path
>>> os.path.abspath('.')
'E:\\TestGit'
>>> os.path.dirname('.')
''
>>> print (os.path.exist('./helloworld.txt'))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute 'exist'
>>> print (os.path.exists('./helloworld.txt'))
True
>>> print (os.path.getatime('./helloworld.txt'))
1468591074.0
>>> print (os.path.getctime('./helloworld.txt'))
1468591074.0
>>> print (os.path.getmtime('./helloworld.txt'))
1468591989.76
>>> print(os.path.isabs('.'))
False
>>> print(os.path.isdir('.'))
True
>>> print(os.path.isfile('.'))
False
>>> print(os.path.split('./helloworld.txt'))
('.', 'helloworld.txt')
>>> print(os.path.splitext('./helloworld.txt'))
('./helloworld', '.txt')
>>> print(os.path.splitdrive('./helloworld.txt'))
('', './helloworld.txt')
>>> print(os.path.split('E:/TestGit/helloworld.txt'))
('E:/TestGit', 'helloworld.txt')
>>> print(os.path.splitdrive('E:/TestGit/helloworld.txt'))
('E:', '/TestGit/helloworld.txt')
>>> src=file('hello.txt',"w")
>>> li=['hello world\n','hello china\n']
>>> src.writelines(li)
>>> src.close()
>>> dst=open('hello2.txt','w')
>>> src=open('hello.txt','r')
>>> dst.write(src.read())
>>> src.close()
>>> dst.close()
>>> os.remove('hello2.txt')
>>> import shutil
>>> shutil.copyfile('hello.txt','hello2.txt')
>>> shutil.move('hello.txt','../')
>>> shutil.move('hello.txt','hello3.txt')
>>> help(os.walk)
Help on function walk in module os:

walk(top, topdown=True, onerror=None, followlinks=False)
    Directory tree generator.
    
    For each directory in the directory tree rooted at top (including top
    itself, but excluding '.' and '..'), yields a 3-tuple
    
        dirpath, dirnames, filenames
    
    dirpath is a string, the path to the directory.  dirnames is a list of
    the names of the subdirectories in dirpath (excluding '.' and '..').
    filenames is a list of the names of the non-directory files in dirpath.
    Note that the names in the lists are just names, with no path components.
    To get a full path (which begins with top) to a file or directory in
    dirpath, do os.path.join(dirpath, name).
    
    If optional arg 'topdown' is true or not specified, the triple for a
    directory is generated before the triples for any of its subdirectories
    (directories are generated top down).  If topdown is false, the triple
    for a directory is generated after the triples for all of its
    subdirectories (directories are generated bottom up).
    
    When topdown is true, the caller can modify the dirnames list in-place
    (e.g., via del or slice assignment), and walk will only recurse into the
    subdirectories whose names remain in dirnames; this can be used to prune
    the search, or to impose a specific order of visiting.  Modifying
    dirnames when topdown is false is ineffective, since the directories in
    dirnames have already been generated by the time dirnames itself is
    generated.
    
    By default errors from the os.listdir() call are ignored.  If
    optional arg 'onerror' is specified, it should be a function; it
    will be called with one argument, an os.error instance.  It can
    report the error to continue with the walk, or raise the exception
    to abort the walk.  Note that the filename is available as the
    filename attribute of the exception object.
    
    By default, os.walk does not follow symbolic links to subdirectories on
    systems that support them.  In order to get this functionality, set the
    optional argument 'followlinks' to true.
    
    Caution:  if you pass a relative pathname for top, don't change the
    current working directory between resumptions of walk.  walk never
    changes the current directory, and assumes that the client doesn't
    either.
    
    Example:
    
    import os
    from os.path import join, getsize
    for root, dirs, files in os.walk('python/Lib/email'):
        print root, "consumes",
        print sum([getsize(join(root, name)) for name in files]),
        print "bytes in", len(files), "non-directory files"
        if 'CVS' in dirs:
            dirs.remove('CVS')  # don't visit CVS directories

>>> 